import slideMe from '../lib/slideMe';

export function microfrontend() {
  return slideMe
    .start("'the king is dead, long live the king'.replace('king','MicroFrontend')")
    .step("https://github.com/tomcask/implementation-microfrontend-slides")
    .doneBy('Tomás Casquero', 'Javascript lover')
    .doneBy('Angel urban', 'always grumpy')
    .index('Our history',{
      manolitoPhp: 'Spaghetti code',
      iframe: 'La la la ya no toco php',
      React: 'ya esta tenemos la solución',
      cleanArchitecture: 'eh tu!! Backender... Yo tambien puedo',
      microfrontend: 'Divina obra!! pero sin Continuous deployment por CO CO CO CO CO'
    })
    .manolitoPhp()
    .step('hizo su trabajo')
    .step('Ahora sabemos mas, queremos cambiarlo')
    .iframe()
    .step('con esto lo peto')
    .step('uy que con esto no voy a ningun sitio')
    .React()
    .step('Vale si dejo a php que renderize')
    .step('Creo un ... ? no se como llamarlo')
    .step('Manager de vistas, un orquestador, una estrella de la muerte ???')
    .step('Vale creo un frontend-react-components pero lo deployo como view-manager')
    .step('Es que los frontend somos unos sediciosos')
    .step('Este view manager se va a encargar de remplazar elementos del dom por react components')
    .step('Somos los amos!!, Como molan los componentes...", "pero si esto crece uff')
    .cleanArchitecture()
    .step('patterns, herencia, ddd, useCase')
    .step('uy cuanta palabreria')
    .step('bueno a ver!!!  tiene sentido dividir en capas')
    .step('Application', {
      Presenter: 'Construye nuestro componente decidiendo que vistas, usecase, infrastructura, store y repository usar',
      Repository: 'tipicamente la implementacion de llamadas a nuestros endpoints',
      State: 'todo lo necesario para gestionar el estado de nuestra aplicacion'
    })
    .step('infrastructure', 'nuestras vistas, third parties, framework, etc...')
    .step('useCases', 'La itencion del usuario, todos los metodos que gestiona, que necesita un usuario, la logica de negocio')
    .step('Domain', 'Entidades anemicas que hacen de parser de las respuestas de backend por aquello de decir que tenemos esta capa')
    .step('Vale todo ordenadito... pero a costa de versionado y mucha mucha muchisima fragmentacion')
    .microfrontend()
    .step('Vale ahora mimso tenemos un view-manager - AKA death star - ')
    .step('Nuestra Death Star importa nuestros componentes publicados en el nexus, los une en un bundle, y los publica como main.js')
    .step('Eso implica que tenemos que compartir las dependencias y por lo tanto problemas:')
    .step('una nueva version en un componente, implica una version de death star')
    .step('un evento de un tracker implica un cambio en el componente y en la death star')
    .step('una propiedad nueva en un evento de tracking, implica un cambio en el componente y en la Death Star')
    .step('un componente por si solo, no sirve de nada, sino se importa en la death-star')
    .step('por lo tanto un deploy a master de un componente, no implica su testeo e2e')
    .step('esto lo tenemos que arreglar,')
    .step('como? pues ... ')
    .step('con microfronteds')
    .step('Que es microfrontends?')
    .step('san google os ayudara...')
    .step('pero el articulo de martin fowler es muy esclarecedor', 'https://martinfowler.com/articles/micro-frontends.html')
    .step('y el video de Luca Mezzalira de DAZN tambien', 'https://www.youtube.com/watch?v=BuRB3djraeM')
    .step('Hay varias tecnicas, iframe, routing, custom-elements, etc')
    .step('nosotros hemos decidido usar el routing')
    .step('Primero nuestros microfrontends los hemos agrupado por layouts')
    .step('Actualmente un merge a master genera publicar un npm package en nuestro nexus para que la death star pueda importarlo')
    .step('Tambien cuando se hace merge a master se genera una docker image con nginx sirviendo el microfrontend bundled')
    .step('Por otro lado, hemos creado un orquestador que escucha las rutas del navegador y las compara con su tabla de rutas')
    .step('esa tabla de rutas no tiene que estar alojada en el orquestador, se puede mantener como un fichero statico en s3')
    .step('dependiendo esas rutas descarga un microfronted o otro')
    .step('inserta el script en el head y llama al callback del microfrontend')
    .step('renderiza un microfrontend pasandole todo lo que necesita para ser indempotente')
    .step('Tambien es responsable del authorization, si no esta autenficado y la ruta lo requiere lo redirige a login')
    .step('Es la muerte de ABAWebApps')
    .step('Bueno nos da un camino para empezar a creernos que podemos matar php')
    .step('Podemos crear un nuevo campus sin php... ACADEMY is here...')
    .step('Pero si volvemos a las ventajas de estos cambios de microfronteds:')
    .step('Somos capaces de deployar un microfrontend de manera independiente')
    .step('Por ejemplo deployar la pagina Home de academy sin tener que deployar las actividades')
    .step('Incluso tambien podemos deployar un unico componente tratandolo como un microfrontend y ser usado desde otro microfrontend sin necesidad de estar en el orquestador')
    .step('Podemos realizar e2e del microfrontend que al ser indempotente nos garantiza su deploy directo a produccion')
    .step('Eliminamos los sideEffects y problemas de gestion de dependencias')
    .step('Cada microfrontend puede usar un framework diferente, react, angular, vue, whatever')
    .step('Ahora mismo estamos haciendo lo mismo que empresas como Spotify, DAZN, New Relic, UpWork, etc')
    .step('Este ha sido uno gran logro personal para mi y no hubiera sido posible sin todos los grandes profesionales que han estado a mi lado. OS QUIERO!!!')
    .step('Mejor despedida que esta no puede haber ;)')
    .end()
}